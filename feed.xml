<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://narkisr' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
Narkisr.com
</title>
<link>
http://narkisr
</link>
<description>
The blog of Ronen Narkis
</description>
<lastBuildDate>
Mon, 22 Dec 2014 23:34:32 +0200
</lastBuildDate>
<author>
Ronen Narkis
</author>
<item>
<guid>
http://narkisr/blog/posts/13-04-2013-tf101-cyanogenmod.html
</guid>
<link>
http://narkisr/blog/posts/13-04-2013-tf101-cyanogenmod.html
</link>
<title>
Asus TF101 Cyanogenmod
</title>
<description>
&lt;h3&gt;&lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;In this post ill try to cover in detail how to root your  &lt;a href='http://www.amazon.com/Transformer-TF101-A1-10-1-Inch-Tablet-Separately/dp/B004U78J1G'&gt;Asus TF101&lt;/a&gt;  device.  Some of the difficuly in rooting android devices is lack of clear undestanding of the process combbined with lack of proper documentation, I hope to clear a bit of the myst in this post. &lt;br /&gt;&lt;h6&gt;&lt;a name=&quot;disclaimer,&amp;#95;i&amp;#95;take&amp;#95;no&amp;#95;responsility&amp;#95;if&amp;#95;you&amp;#95;brick&amp;#95;you&amp;#95;device&amp;#95;or&amp;#95;any&amp;#95;other&amp;#95;damage&amp;#95;that&amp;#95;this&amp;#95;might&amp;#95;inflict&amp;#95;on&amp;#95;your&amp;#95;device,&amp;#95;proceed&amp;#95;at&amp;#95;your&amp;#95;own&amp;#95;peril!&quot;&gt;&lt;/a&gt;DISCLAIMER, I take no responsility if you brick you device or any other damage that this might inflict on your device, proceed at your own peril!&lt;/h6&gt;&lt;h4&gt;&lt;a name=&quot;scheme&quot;&gt;&lt;/a&gt;Scheme&lt;/h4&gt;A root session is composed from 4 steps: &lt;ul&gt;&lt;li&gt;Rooting your device (basicly enabling root user access to underlying Linux system).&lt;/li&gt;&lt;li&gt;Install  ClockworkMod Recovery(http://forum.xda-developers.com/wiki/ClockworkMod_Recovery)  which is a recovery tool installed on the device, this enables unpacking of custom Android distributions on your device (like &lt;a href='http://www.cyanogenmod.org/'&gt;cyanogenmod&lt;/a&gt; &quot;).&quot;&lt;/li&gt;&lt;li&gt;Booting into CWM and installing a custom ROM from a predownloaded zip file.&lt;/li&gt;&lt;li&gt;Instaling Google aps from a pre download zip file (the reason this is required is because Google forbided the bundling of its closed source product with the custom ROM).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Lets begin with rooting the device, we will follow  &lt;a href='http://setupguides.blogspot.co.il/2013/01/easily-root-asus-tf101-transformer.html'&gt;this&lt;/a&gt;  method, first we will install adb and fastboot (both are android tools for interacting with the device) as described  &lt;a href='http://www.webupd8.org/2012/08/install-adb-and-fastboot-android-tools.html'&gt;here&lt;/a&gt; :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ sudo add-apt-repository ppa:nilarimogard/webupd8
$ sudo apt-get update
$ sudo apt-get install android-tools-adb android-tools-fastboot
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now enable usb debbuging in your device and connect it to your pc, it should be detected by adb:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ adb devices                                                                  
List of devices attached 
xxxxxxxxxxxxxxx device
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we will download TF101_Root.zip which includes a script and blob file that will uploaded via adb &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ wget http://ubuntuone.com/5xwKVscUxwgdnudw589ERd -O TF101&amp;#95;Root.zip
$ unzip TF101&amp;#95;Root.zip
# Now I follow root&amp;#95;tf101.sh
$ adb push recoveryblob /sdcard/
$ adb shell mv /data/local/tmp /data/local/tmp.bak
$ adb shell ln -s /dev/block/mmcblk0p4 /data/local/tmp
$ adb reboot 
# wait to device to boot before proceeding
$ adb shell dd if=/sdcard/recoveryblob of=/dev/block/mmcblk0p4
$ adb shell exit
$ adb reboot 
# wait to device to boot before proceeding
$ adb push Superuser-3.0.7-efghi-signed.zip /sdcard/
$ adb reboot 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now at the last boot follow the script maunal steps: &lt;blockquote&gt;  Shut down the Transformer manually and boot into recovery. To boot into recovery hold Power + Volume Down buttons and next confirm with Volume Up buked. Rogue XM recovery will boot.&lt;br /&gt; Select the option to wipe cache, wipe Dalvik cache, then choose Install zip file from internal storage and choose the Superuser-3.0.7-efghi-signed.zip. &lt;/blockquote&gt;&lt;/p&gt;&lt;p&gt;Congrates you have root access now.&lt;/p&gt;&lt;p&gt;Now lets head on to installing CWM, from your device download  &lt;a href='http://goo.im/devs/RaymanFX/downloads/ClockWordMod-Recovery/TF101/cwm-6.0.2.1-notouch-hybrid.zip'&gt;cwm-6.0.2.1-notouch-hybrid.zip&lt;/a&gt;  as referenced from this forum &lt;a href=' http://forum.xda-developers.com/showthread.php?t=1855686'&gt;entry&lt;/a&gt;  , reboot into recovery mode (same as before) and apply the zip, reboot again and use the volume-up and power button to enter into CWM recovery.&lt;/p&gt;&lt;p&gt;Once you see the CWM recovery loading and working we can proceed with installing the unofficial cyanogenmod as reviewed  &lt;a href='http://forum.xda-developers.com/showthread.php?t=2010903'&gt;here&lt;/a&gt; , from within your device browser download  &lt;a href='http://goo.im/getmd5/devs/RaymanFX/downloads/CyanogenMod-10.1/TF101/v0.8.0.zip'&gt;v0.8.0.zip&lt;/a&gt;  and Google apps  &lt;a href='http://goo.im/devs/RaymanFX/downloads/Gapps/4.2&amp;#95;gapps-jb-20121119.zip'&gt;4.2&amp;#95;gapps-jb-20121119.zip&lt;/a&gt; , now boot into CWM and apply the v0.8.0.zip from internal sdcard, also clear the device and dalvik caches reboot into the new Android OS.&lt;/p&gt;&lt;p&gt;Note that it will be missing Google apps but we still need to boot into the new OS before applying the second Google apps zip, now its safe to boot into CWM and apply the 4.2_gapps-jb-20121119.zip, one last reboot and you should be greated with Google acount setup dialog.&lt;/p&gt;
</description>
<pubDate>
Sat, 13 Apr 2013 00:00:00 +0300
</pubDate>
<author>
Ronen Narkis
</author>
</item>
<item>
<guid>
http://narkisr/blog/posts/24-07-2012-waiting-for.html
</guid>
<link>
http://narkisr/blog/posts/24-07-2012-waiting-for.html
</link>
<title>
Waiting for your future
</title>
<description>
&lt;p&gt; So, you've got an action that you want to run in parallel using multiple cores, in pure Java land you have the old fashioned Thread.start which takes a Runnable implementation, another option is the  &lt;a href='http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html'&gt;ExecutorService&lt;/a&gt;  which uses a pool to store a collection of reusable threads (in fact its the same pool that agents use).  Clojure on the other hand has the  &lt;a href='http://clojuredocs.org/clojure&amp;#95;core/clojure.core/future'&gt;future&lt;/a&gt;  macro which takes a body of code and runs it on a seprate thread:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def f &amp;#40;future &amp;#40;println &amp;quot;hello&amp;quot;&amp;#41;&amp;#41;&amp;#41;
  
@f ; will block here until it executes 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Futures use an unbound thread pool which is good for IO bound actions, lets assume we have a sequence (a large one at that) that serves as an input to that heavy IO operation, we want to parallelize the operation on multiple cores, the naive approach will be:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt; &amp;#40;defn action &amp;#91;i&amp;#93;
    &amp;#40;Thread/sleep 4000&amp;#41;
    &amp;#40;println i&amp;#41;&amp;#41;

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;map &amp;#40;future &amp;#40;action %&amp;#41;&amp;#41; &amp;#40;range 1000&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running this code will result with no future run, the main thread will exit before any future gets the chance to execute (since its async), in order to wait for them to run we need to deref all futures,&lt;br /&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt; &amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;map deref &amp;#40;map &amp;#40;future &amp;#40;action %&amp;#41;&amp;#41; &amp;#40;range 1000&amp;#41;&amp;#41;&amp;#41;&amp;#41; 
&lt;/code&gt;&lt;/pre&gt;This looks good and indeed when we run it we notice the following output&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;0
1 
.. ; omitted for brevity 
.. 
31
nil nil nil  ; after a delay 
32
..
..
63 ; order is random 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So whats going on here? we a get a lot less concurrency then we'd like, what we see here is Clojure chunking in action, since the inner map is lazy we produce 32 futures in each chunk deref them and carry on to the next, we could force all futures by using doall:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;map deref &amp;#40;doall &amp;#40;map &amp;#40;future &amp;#40;action %&amp;#41;&amp;#41; &amp;#40;range 1000&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This poses another problem, we issue 1000 future and hammer on, this might cause the IO target to grind into a halt (be it filesystem or remote web service), a more controled method is required.  One option is to use Java's own ExecutorService and submit actions into that (using a bounded pool) and in fact thats exactly what &lt;a href='https://github.com/pallet/pallet-thread'&gt;pallet thread&lt;/a&gt;  enables us to do.&lt;/p&gt;&lt;p&gt;Now we want to implement two main requirements, the first generate a blocked amount of running actions, the second make sure not to block the execution of actions (by chunking for example) if threads are available to handle them:&lt;br /&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;use '&amp;#91;pallet.thread.executor :only &amp;#40;executor execute&amp;#41;&amp;#93;&amp;#41;  
 
&amp;#40;def pool
  &amp;#40;executor {:prefix &amp;quot;foo&amp;quot; :thread-group-name &amp;quot;foo-grp&amp;quot; :pool-size 4}&amp;#41;&amp;#41;

&amp;#40;defn bound-future &amp;#91;f&amp;#93;
 {:pre &amp;#91;&amp;#40;ifn? f&amp;#41;&amp;#93;}; saves lots of errors
  &amp;#40;execute pool f&amp;#41;&amp;#41;

&amp;#40;defn wait-on &amp;#91;futures&amp;#93;
  &amp;quot;Waiting on a sequence of futures, limited by a constant pool of threads&amp;quot;
  &amp;#40;while &amp;#40;some identity &amp;#40;map &amp;#40;comp not future-done?&amp;#41; futures&amp;#41;&amp;#41;
    &amp;#40;Thread/sleep 1000&amp;#41; 
    &amp;#41;&amp;#41; 

&amp;#40;defn -main &amp;#91;&amp;#93;
  &amp;#40;wait-on &amp;#40;map #&amp;#40;bound-future &amp;#40;fn &amp;#91;&amp;#93;  &amp;#40;action %&amp;#41;&amp;#41;&amp;#41; &amp;#40;range 1000&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The print will now look like &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;0
1
2
3
; a short delay for the next 4 actions to kick into action
1
..
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I found this method to offer a balance between the spread of work and predictable load on the target.&lt;/p&gt;
</description>
<pubDate>
Tue, 24 Jul 2012 00:00:00 +0300
</pubDate>
<author>
Ronen Narkis
</author>
</item>
<item>
<guid>
http://narkisr/blog/posts/20-07-2012-raspberri-pi.html
</guid>
<link>
http://narkisr/blog/posts/20-07-2012-raspberri-pi.html
</link>
<title>
Raspberry foo
</title>
<description>
&lt;p&gt;Iv been lucky to get my hands on a raspberry pie, from the get go it was clear that this device isn't ready for the faint hearted, while there is abundant content around for how to start going the pi is a moving target and things change quickly, this post is a quick start for getting pie going. &lt;/p&gt;&lt;h5&gt;&lt;a name=&quot;in&amp;#95;this&amp;#95;post&amp;#95;will&amp;#95;cover&quot;&gt;&lt;/a&gt;In this post will cover&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;Downloading sdcard image and \&quot;dd'ing\&quot;&lt;/li&gt;&lt;li&gt;Enabling SSH and updating Pi's frimware.&lt;/li&gt;&lt;li&gt;Enabling wifi with the 8192cu chipset:p&lt;/li&gt;&lt;/ul&gt;&lt;h5&gt;&lt;a name=&quot;downloading&amp;#95;and&amp;#95;dding&quot;&gt;&lt;/a&gt;Downloading and dding&lt;/h5&gt;The pi site offers both Arch and Debian  &lt;a href='http://www.raspberrypi.org/downloads'&gt;images&lt;/a&gt;, iv went ahead with Debian mainly since its closer to Ubuntu, note that there are  [beta] (http://rpi-developers.com/frs/download.php/file/20)  &quot; versions out there but iv found the stock one working best.&quot;.&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt; $ sudo dd bs=1M if=debian6-19-04-2012.img of=/dev/sdb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When its done push the sdcard into its slot, make sure to connect the screen before powering up (iv had issue with connecting DVI cable once it was running),&lt;br /&gt; as the boot is done connect it to the internet and run all the updates (note sudo password is raspberry by default, change it afterwards).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ sudo aptitude update
$ sudo aptitude upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;a name=&quot;sshing&quot;&gt;&lt;/a&gt;SSHing&lt;/h5&gt;Its time to get our monitor back, we will enable SSH so we can work remotely:&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# boot enable
$ sudo update-rc.d ssh

# ssh won't start without this
$ ssh-keygem -b 1024 -t rsa -f /etc/ssh/ssh&amp;#95;host&amp;#95;key 
$ ssh-keygen -b 1024 -t rsa -f /etc/ssh/ssh&amp;#95;host&amp;#95;rsa&amp;#95;key 
$ ssh-keygen -b 1024 -t rsa -f /etc/ssh/ssh&amp;#95;host&amp;#95;dsa&amp;#95;key 

# enable firewall
$ sudo aptitude install ufw
$ sudo ufw allow 22 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now will update Pi's frimware:&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# updating frimware
$ sudo wget --no-check-certificate http://goo.gl/1BOfJ -O /usr/bin/rpi-update 
$ sudo chmod +x /usr/bin/rpi-update
$ sudo apt-get install git-core
# avoiding http://tinyurl.com/cbauu4w  
$ sudo ldconfig
$ sudo rpi-update  
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;h5&gt;&lt;a name=&quot;wifi&quot;&gt;&lt;/a&gt;Wifi&lt;/h5&gt;The hardest part in setting up the pi is enabling wireless, this boils down to two main reasons, power consumption and driver compatibility (kernel version wise). The pi is powered by a 5v power supply (usb phone charger), this means that it has little power to spare for devices connected to its usb ports, high power long range wifi dongle require too much juice. &lt;p&gt;Among the low bandwidth cost adapters that iv found the  &lt;a href='http://www.amazon.co.uk/Edimax-EW-7811UN-Wireless-802-11b-150Mbps/dp/B003MTTJOY'&gt;EW-7811UN&lt;/a&gt;  draws very little power, in addition it has a very low profile making it barely visible on the pi board, now comes the fun part of making it work.&lt;/p&gt;&lt;p&gt;The info of how setting it up is scattered and inconsistent, the best source out there for setting it up is this forum  &lt;a href='http://www.raspberrypi.org/phpBB3/viewtopic.php?t=6256'&gt;post&lt;/a&gt;   by MrEngman , the post provides a  &lt;a href='http://dl.dropbox.com/u/80256631/install-rtl8188cus.sh'&gt;shell script&lt;/a&gt;  and  &lt;a href=' http://dl.dropbox.com/u/80256631/install-rtl8188cus.txt'&gt;instructions&lt;/a&gt;  on how to use it,  under compatibility section you can see which driver version matches a kernel version&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ uname -a 
Linux raspberrypi 3.1.9+ #171 PREEMPT Tue Jul 17 01:08:22 BST 2012 armv6l GNU/Linux

# The matching driver version 
rtl8188cus driver versions and compatible Linux versions


Driver tar file: 8192cu-20120701.tar.gz &amp;#40;http://dl.dropbox.com/u/80256631/8192cu-20120701.tar.gz&amp;#41;
For kernel versions:

Linux raspberrypi 3.1.9+ #171 PREEMPT Tue Jul 17 01:08:22 BST 2012 armv6l GNU/Linux 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run the installation script:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ sudo ./install-rtl8188cus.sh  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lets inspect the results:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;
# the 8192cu driver is in place
$ sudo ls /lib/modules/3.1.9+/kernel/net/wireless
8192cu.ko  cfg80211.ko	lib80211.ko  lib80211&amp;#95;crypt&amp;#95;ccmp.ko  lib80211&amp;#95;crypt&amp;#95;tkip.ko  lib80211&amp;#95;crypt&amp;#95;wep.ko

$ sudo cat /etc/network/interfaces | grep wlan0 -A 5 
allow-hotplug wlan0

auto wlan0

iface wlan0 inet dhcp
wpa-ssid &amp;quot;ssid&amp;quot;
wpa-psk &amp;quot;pass&amp;quot;

$ ifconfig | grep wlan
wlan0     Link encap:Ethernet  HWaddr 00:1f:1f:f2:ff:f8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Enjoy your pie!&lt;br /&gt;&lt;/p&gt;
</description>
<pubDate>
Fri, 20 Jul 2012 00:00:00 +0300
</pubDate>
<author>
Ronen Narkis
</author>
</item>
</channel>
</rss>
