<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Narkisr.com: Rules, not what you recall</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" >
    <!-- <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"> -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/default.min.css">
        <link href="/css/screen.css" rel="stylesheet" type="text/css" />
	  <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
	  <link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
    <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
        <div class="container">

            <div class="navbar-header">

                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
			  <span class="icon-bar"></span>
			</button>
		    </div>

				    <!-- nav links -->
		    <div id="navbar" class="navbar-collapse collapse">
			<ul class="nav navbar-nav">
			  <li ><a href="/">Home</a></li>
			  <li ><a href="/archives/">Archives</a></li>
			  
			  <li >
			  <a href="/pages/projects/">Projects</a>
			  </li>
			  
			  <li >
			  <a href="/pages/presentations/">Presentations</a>
			  </li>
			  
			  <ul class="nav navbar-nav navbar-right">
			    <li><a class="btn" href=/atom.xml ><i class="fa fa-rss"></i></a></li>
			    <li><a class="btn" href="http://twitter.com/narkisr" ><i class="fa fa-twitter"></i></a></li>
			    <li><a class="btn" href="https://github.com/narkisr" ><i class="fa fa-github-alt"></i></a></li>
			    <li><a class="btn" href="http://il.linkedin.com/in/narkisr/" ><i class="fa fa-linkedin"></i></a></li>
			  </ul>


			</ul>
		    </div><!--/.nav-collapse -->
		  </div>
		</nav>

		<div id="wrapper" class="container">
		  <div class="row">
		    <div class="col-md-8">
			<div id="content">
			  
<div id="post">
    <div id="post-header">
    <h2>Rules, not what you recall</h2>
    <div id="post-meta">
        
        <div class="date">April 27, 2020</div>
    </div>
</div>
<div>
    
    <h3 id="intro">Intro</h3><p>Like most developers I used to think on rule engines as a interesting technology that never took off, a common misconception around them was that they would enable domain experts to encode rules into them without the need of having developers in this process (reducing cost/implementation time).</p><p>As expected this never worked in practice and as projects failed interest dwindled and they were left as an historical relic together with <a href='https://en.wikipedia.org/wiki/Visual_programming_language'>visual programming</a>.</p><p>In this post I will try to revive the interest in using a rule engine and cover how I use <a href='https://github.com/cerner/clara-rules'>Clara rules</a> in an interesting domain - operation flow automation.</p><h3 id="so&#95;what&#95;are&#95;rule&#95;engines?">So what are rule engines?</h3><p>A Rule engine include 3 main types of components:</p><ul><li>Facts, information that our system get from the world.</li><li>Rules, how those facts effect our world</li><li>Queries that we may run in order to find what kind of rules were activate and why.</li></ul><p>The underlying implementation uses a directed acyclic graph and an algorithm named <a href='https://en.wikipedia.org/wiki/Rete_algorithm'>RETE</a> for efficient computation on top of a large sets of rules and facts.</p><p><small> * If the above rings a bell of Logic programming and expert system you are not mistaken with the later usually being implemented in Prolog.</small></p><p>A basic rule in Clara is composed from a left hand side (a match on facts) and the right hand side (the effect of a match) separated by '=>', in this case we match on facts that have a :state value of ::start :</p><pre><code class="clojure">&#40;ns foo&#41;

&#40;defrule example
  &quot;An example rule&quot;
  ; What to match on
  &#91;?e &lt;- ::start&#93;
  =&gt;
  ; The effect of the match
  &#40;println &quot;foo&quot;&#41;
  &#40;insert! {:state ::done :failure false}&#41;&#41;
</code></pre><p>Lets note a couple of interesting points here:</p><ul><li>The RHS doesn't have to be side effect free! (see that lovely println)</li><li>The RHS can insert new facts into the system.</li><li>We can capture the incoming matched fact in variables (?e), this allows us to pass in arbitrary information to the rules.</li><li>Our facts are plain old Clojure maps (we can create them from any arbitrary input).</li></ul><p>Our rule engine state (RETE remember?) is an immutable data structure (<a href='https://en.wikipedia.org/wiki/Turtles_all_the_way_down'>turtles</a> all the way down) that we store in an atom:</p><pre><code class="clojure">&#40;defn initialize &#91;&#93;
  &#40;atom &#40;mk-session 'foo&#41;&#41;&#41;

&#40;def session &#40;initialize&#41;&#41;
</code></pre><p>If we want to insert new facts into it (while keeping our old view of the world) we can just reset it:</p><pre><code class="clojure">&#40;defn update- &#91;facts&#93;
  &#40;let &#91;new-facts &#40;reduce &#40;fn &#91;s fact&#93; &#40;insert s fact&#41;&#41; @session facts&#41;&#93;
    &#40;reset! session &#40;fire-rules new-facts&#41;&#41;&#41;&#41;

&#40;commment
  ; update our view of the world
  &#40;update- {:state :foo/start :yet :another :key 1}&#41;&#41;
</code></pre><p>We can also query our session and ask what happened:</p><pre><code class="clojure">&#40;defquery get-failures
  &quot;Find all failures&quot;
  &#91;&#93;
  &#91;?f &lt;- :re-flow.core/state &#40;= true &#40;this :failure&#41;&#41;&#93;&#41;
</code></pre><h2 id="existing&#95;approaches">Existing approaches</h2><p>Lets take a step back and cover what a conditional is composed out of:</p><ul><li>A predicate (the when of an IF statement).</li><li>The result of a match on a predict (the logic that happens after a match).</li><li>The computation flow (the cause and effect graph).</li></ul><p>We use conditional logic when we try to describe the flow of steps in a distributed process like  for example a remote backup restore test:</p><ul><li>Create a VM with a volume to restore our data to</li><li>Provision the VM with the required tooling and prepare our volume</li><li>Check that we are ready to start the restore process (our VM is ready and our volume has the correct size)</li><li>Restore the data and verify that it was successful</li><li>Notify on success or failure</li></ul><p>There are a number of ways to model this kind of flow, the simplest one is to use conditionals:</p><pre><code class="clojure">&#40;defn restore-backup &#91;backup&#93;
  &#40;let &#91;{:keys &#91;created?&#93; :as creation-result} &#40;create-vm&#41;&#93;
     &#40;if-not vm-create?
         &#40;throw &#40;ex-info &quot;failed to create the VM&quot; creation-result&#41;&#41;
         &#40;let &#91;{:keys &#91;provisioned?&#93; :as provisioning-result} &#40;provision&#41;&#93;
            ; rest of the flow
            &#41;&#41;&#41;&#41;
</code></pre><p>There are a number of issue with this approch:</p><ul><li>As <a href='https://en.wikipedia.org/wiki/Cyclomatic_complexity'>Cyclomatic complexity</a> explodes its really hard to reason about the code.</li><li>Composition is challenging since trying to compose one chain of conditional logic with another is fragile.</li><li>The only way to understand failure points in the code is by painstaking debugging and printing.</li></ul><p>Another approach is to use finite state machines (FSM for short), the following FSM has a :start state and a number of transitions defined:<pre><code class="clojure">&#40;defsm restore
  &#91;&#91;:start
    ::create -&gt; &#40;create-vm&#41;&#93;
   &#91;:created
    true -&gt;  &#40;provision&#41;
    false -&gt; &#40;report-error&#41;&#93;
   &#91;:provisioned
    true -&gt;  &#40;restore&#41;
    false -&gt; &#40;report-error&#41;&#93;
  &#91;:restored
    true -&gt;  &#40;printrln &quot;success&quot;&#41;
    false -&gt; &#40;report-error&#41;&#93;
   &#93;&#41;
</code></pre></p><p>On a first glance this looks promising as it frees us from the conditional nesting but there are still a number of issues:</p><ul><li>Location information is still complected making change in a large set of FMS's is still tricky.</li><li>They are not easy to compose (think about combining the restore FSM with a new notification FSM)</li><li>They lack introspection (understand why we reached a certain state within them).</li></ul><p>There are other approaches that solve the same problem but I would like to claim (while not providing a rigorous mathematical proof) that they are <a href="https://en.wikipedia.org/wiki/Reduction_(complexity)">reducible </a> to the two approaches mentioned above.</p><h3 id="the&#95;case&#95;fore&#95;clara&#95;rules">The case fore Clara rules</h3><p>Coming back to the same problem space (restoration flow) our code now is composed out of a two sets of rules, the first one is the creation and provisioning logic:</p><pre><code class="clojure">&#40;ns re-flow.setup
  ;...
  &#41;

&#40;defrule creating
  &quot;Create VM&quot;
  &#91;?e &lt;- ::creating &#91;&#93;&#93;
  =&gt;
  &#40;insert! &#40;assoc ?e :state ::created :failure &#40;create-vm&#41;&#41;&#41;


&#40;defrule provisioning
  &quot;Provisioning&quot;
  &#91;?e &lt;- ::created &#40;= ?failure false&#41;&#93;
  =&gt;
   ; ....
   &#40;info &quot;provisioning&quot;&#41;
   &#40;insert! &#40;assoc ?e :state ::provisioned :failure &#40;provision&#41;&#41;&#41;&#41;
</code></pre><p>Note that we didn't specify the order of execution we only provided the predicate and the effect of a match.</p><p>Our restoration logic is completely decoupled from the creation logic (it resides in a different namespace), it does not care on how the instance is coming to life it only concern itself with what it should do once its up and running:</p><pre><code class="clojure">&#40;ns re-flow.restore
  ;...
  &#41;

&#40;defrule check
  &quot;Check that the ?e fact is matching the ::restore spec&quot;
  &#91;?e &lt;- ::start&#93;
  =&gt;
  &#40;insert! &#40;assoc ?e :state ::spec :failure &#40;not &#40;s/valid? ::restore ?e&#41;&#41;&#41;&#41;&#41;

&#40;defrule create
  &quot;Triggering the creation of the instance&quot;
  &#91;?e &lt;- ::spec &#91;{:keys &#91;failure&#93;}&#93; &#40;= failure false&#41;&#93;
  =&gt;
  &#40;info &quot;Starting to run setup instance&quot;&#41;
  &#40;insert!  &#40;assoc ?e :state :re-flow.setup/creating :spec instance&#41;&#41;&#41;

&#40;defrule restore
  &quot;Restoring information&quot;
  &#91;?e &lt;- ::provisioned &#91;{:keys &#91;failure&#93;}&#93; &#40;= failure false&#41;&#93;
  =&gt;
  &#40;insert! &#40;assoc ?e :state ::restored :failure &#40;restore&#41;&#41;&#41;
</code></pre><p>The check rule matches on the ::start state fact where ?e is captured and verified against a spec, the second rule trigger the creation flow if the ::spec fact failure value is false.</p><p>In order to launch this flow we insert a fact into our session:</p><pre><code class="clojure">; We provide the backup information as a map within the fact
&#40;update- {:state :re-flow.restore/start :backup {:source &quot;s3://&quot; ...}&#41;
</code></pre><p>We may use the query we already defined to find what rule fail:</p><pre><code class="clojure">&#40;defn run-query &#91;q&#93;
  &#40;query @session q&#41;&#41;

; The query result is a native Clojure datastucture
&#40;run-query get-failures&#41;
</code></pre><p>This approach has a number of clear advantages:</p><ul><li>Logic is decoupled its easy to make changes to one rule without breaking other rules.</li><li>Composition is easy, one set of rules can trigger other rules from other namespaces.</li><li>Tracking failure and other information is easy (just write queries)</li><li>We get the execution engine for free (computation graph).</li></ul><p>A number of other key points that we should cover:</p><ul><li>The engine does not deal with concurrency however its immutable which allows us to set the new engine state using native Clojure Refs.</li><li>The Rules are not persisted to disk by default if we choose to do so we can serialize its state and persist it.</li><li>The engine state is not a distributed data structure, if we have multiple JVM's we can shard our facts based on keys (think Kafka consumers).</li></ul><h3 id="summary">Summary</h3><p>Iv found Clara rules to be a really powerful tool for automation if you are curious check <a href='https://github.com/re-ops/re-core/tree/master/src/re_flow'>Re-core</a> code, ill conclude this post with my own variation on Greenspuns tenth <a href='https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule'>rule</a>:</p><p>"Every complex yml/json that describes a complex pipeline is interpreted by an ad hoc informally-specified, bug-ridden, slow implementation of a Forward-chaining rules engine"</p><p>  Pipelines are computation graphs</p><h4 id="footnotes:">Footnotes:</h4><ul><li><small>Martin fowler mentioning the <a href='https://martinfowler.com/bliki/RulesEngine.html'>misconception</a>.</small></li><li><small>The connection between Expert <a href='https://en.wikipedia.org/wiki/Expert_system'>systems</a> and rule engines.</small></li></ul>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/re-ops/">re-ops</a>
    
    <a href="/clara/">clara</a>
    
    <a href="/functional/">functional</a>
    
    <a href="/flows/">flows</a>
    
</div>

    <div id="prev-next">
        
        
        
        <a href="/posts/20-02-2018-wacky/">Speculative execution &raquo;</a>
        
    </div>

</div>

			</div>
		    </div>

		    <div class="col-md-3">
			<div id="sidebar">
			  <ul id="links">

			    
			    <li><a href="/pages/about/">About</a></li>
			    
			  </ul>
			  <div id="recent">
			    <h3>Recent Posts</h3>
			    <ul>
				
				<li><a href="/posts/27-04-2020-clara-flow/">Rules, not what you recall</a></li>
				
				<li><a href="/posts/20-02-2018-wacky/">Speculative execution</a></li>
				
				<li><a href="/posts/04-02-2018-types-mismatch/">When types are eating away your sanity</a></li>
				
			    </ul>
			  </div>
			  <div id="tags">
			    <h3>Tags</h3>
			    <ul>
				
				<li><a href="/js/">js</a></li>
				
				<li><a href="/security/">security</a></li>
				
				<li><a href="/dependencies/">dependencies</a></li>
				
				<li><a href="/raspberry/">raspberry</a></li>
				
				<li><a href="/encryption/">encryption</a></li>
				
				<li><a href="/cyanogenmod/">cyanogenmod</a></li>
				
				<li><a href="/wifi/">wifi</a></li>
				
				<li><a href="/design/">design</a></li>
				
				<li><a href="/asus/">asus</a></li>
				
				<li><a href="/opskeleton/">opskeleton</a></li>
				
				<li><a href="/tf101/">tf101</a></li>
				
				<li><a href="/management/">management</a></li>
				
				<li><a href="/software/">software</a></li>
				
				<li><a href="/linux/">linux</a></li>
				
				<li><a href="/types/">types</a></li>
				
				<li><a href="/pi/">pi</a></li>
				
				<li><a href="/re-core/">re-core</a></li>
				
				<li><a href="/Clojure/">Clojure</a></li>
				
				<li><a href="/vagrant/">vagrant</a></li>
				
				<li><a href="/concurrency/">concurrency</a></li>
				
				<li><a href="/re-ops/">re-ops</a></li>
				
				<li><a href="/clara/">clara</a></li>
				
				<li><a href="/functional/">functional</a></li>
				
				<li><a href="/future/">future</a></li>
				
				<li><a href="/re-mote/">re-mote</a></li>
				
				<li><a href="/impedance/">impedance</a></li>
				
				<li><a href="/android/">android</a></li>
				
				<li><a href="/raspberry-pi/">raspberry-pi</a></li>
				
				<li><a href="/nodejs/">nodejs</a></li>
				
				<li><a href="/flows/">flows</a></li>
				
				<li><a href="/operations/">operations</a></li>
				
			    </ul>
			  </div>
			</div>
		    </div>
		  </div>
		  <footer class="footer"><div class="span-24 small quite last">
			<span href="http://purl.org/dc/dcmitype/Text" property="dc:title" rel="dc:type" xmlns:dc="http://purl.org/dc/elements/1.1/"> This website content</span> by <a href="narkisr.com" property="cc:attributionName" rel="cc:attributionURL" xmlns:cc="http://creativecommons.org/ns#"> Ronen Narkis </a> is licensed under a <a href="http://creativecommons.org/licenses/by/2.5/il/" rel="license">Creative Commons Attribution 2.5 Israel License</a>, based on a work at <a href="narkisr.com" rel="dc:source" xmlns:dc="http://purl.org/dc/elements/1.1/">narkisr.com</a>, Permissions beyond the scope of this license may be available at <a href="narkisr.com" rel="cc:morePermissions" xmlns:cc="http://creativecommons.org/ns#">narkisr.com</a>.</div>
		  </footer>
		</div>
		<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
		<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.0/js/bootstrap.min.js"></script>
		<script src="/js/highlight.pack.js" type="text/javascript"></script>
		<script>hljs.initHighlightingOnLoad();</script>
	    </body>
	  </html>

