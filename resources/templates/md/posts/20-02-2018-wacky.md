{:title "Speculative execution"
 :layout :post
 :tags  ["re-ops" "operations" "functional" "flows" "re-core" "re-mote"]
 :toc false}

### Intro
One of the things that I find about good tools is that they allow creative exploration of ideas, in this post ill cover some of more imaginative the flows that Re-ops may support.

The flows that I'm going to present are not implemented, but Re-ops makes them all possible due to its basic architecture and design.

## Voice up

There are a lot of cases where it makes sense to create/start a VM/Physical machine, lets take for example your media server, or a remote development machine, we need those only on specific times yet we usually run them 24/7, but what if we could trigger them based on our needs?


```clojure
(defn plex-on []
  (run (start) | (alexa :reply "ok")))

(defn update-all []
  (run (update) | (alexa :reply "ok"))

; start VM instances by saying 'Alexa start plex on'
(wemo (alexa :event "plex power on") (plex-on))

; updating all the machine by saying 'Alexa update all'
(wemo (alexa :event "update all") (update-all))

```

Now this flow isn't implemented now, I suspect it should pretty easy to implement by exposing a WeMO like interface and pretending to be one or more devices.

Another good options (tough it will require a bit more setup) is to use MQTT, the main issue here is exposing the MQTT broker to Alexa.

## Sensors

Another cool idea is to integrate Re-ops with sensors:

```clojure
; our closet instances (including the physical hypervisor big-iron)
(def closet (Hosts. {} ["foo" "bar" "big-iron"]))

; Stopping our closet instances when it gets too hot (beyond 70c)
(def check-temp [t]
  (when (> t 70)
    (run (stop hs) | (email to-from "stopped all closed instances, room too hot"))

(watch :temp once-an-hour (check-temp (sensor :temperture))

```

Here we would stop all the VM's and the hosts if our server room (aka our closet) gets too hot thus preventing hardware meltdown while we are not near, we would need to exposing an MQTT end point and the rest should be pretty easy to follow.

A more far out scenario is automating our machines based on sensor detecting power output from solar panels (is it sunny enough or not) if there isn't not enough sun we would rather now use costly energy from the electricity provider, we start the mining farm based on the power costs:

```clojure
; our mining instances (including physical hypervisor big-iron)
(def mining-pool (Hosts. {} ["coin-1" "coin-1" "big-iron"]))

; We produce more then 10KW of power lets start mining
(defn enough-power [kwh]
  (when (> kwh 10)
    (run (start mining-pool))))

; We produce less then 10KW of power lets stop mining
(defn lacking-power [kwh]
  (run (stop mining-pool))


(watch :power-ok once-an-hour (enough-power (check-power)))
(watch :power-ok once-an-hour (lacking-power (check-power)))

```

## Scanning
Running a scanning tool on a regular basis is a good way for checking compliance and detect potential security issues:

```clojure

(def suspicious-ports #{25 ...})
(def scanner (Hosts. {} ["scanner"]))

(defn scan []
  (run (open-ports scanner) | (pick (fn [ports] (suspicious-ports ports))) | (email "suspicious ports found"))

(watch :nmap (every-day 22) (scan hosts))

```
Using a scanner host enables us to:

* Selectively allow password-less sudo access instance for the specific VM
* Have scanning agents running within segmented networks


## Spot instances

In AWS we can bid for EC2 instances and offer a max price we are willing to pay for them, for some workload (batch proessing) this can be really cost effective.

The main down side is that we do this bidding only against EC2, what if we could have a cost tree where we could decide dynamically whether to use one provide or another:

```clojure
; some long batch job
(def batch (Hosts. {} ["worker-1" "worker-2" "master"]))

; AWS cost per hour bellow $0.0058 per Hour
(defn aws-spots [c]
  (run (pick (fn [c] (< c 0.0058)))  | (destroy batch) | (create batch aws-spot-instance)))


; AWS too expansive we will run locally
(defn local-kvm [c]
  (run (pick (fn [c] (> c 0.0058)))  | (destroy batch) | (create batch kvm-medium)))


; The cost changes will be collected on 1 hour basis so we won't flap too often.
(watch :aws-spots once-an-hour (aws-spots (cost :ec2-cost)))
(watch :local-kvm once-an-hour (local-kvm (cost :ec2-cost)))

```

## Summary
In this post we explored some of the more speculative (yet possible) workflows that Re-ops may enable, having a flexible and fully programmable tool can really lead to interesting ideas and implementation.



#### Footnotes:
* <small>[WeMo](http://www.belkin.com/au/Products/home-automation/c/wemo-home-automation/) home automation.</small>
* <small>[MQTT](http://mqtt.org/) protocol,</small>
* <small>AWS [Spot](https://aws.amazon.com/ec2/spot/) instances</small>


